/* WARNING: THIS FILE IS AUTOMATICALLY GENERATED BY 'generator.pl'.
 * Any changes you make to this file may be overwritten.
 */

/* OCaml bindings for libvirt.
 * (C) Copyright 2007-2008 Richard W.M. Jones, Red Hat Inc.
 * http://libvirt.org/
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 */

#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <libvirt/libvirt.h>
#include <libvirt/virterror.h>

#include <caml/config.h>
#include <caml/alloc.h>
#include <caml/callback.h>
#include <caml/custom.h>
#include <caml/fail.h>
#include <caml/memory.h>
#include <caml/misc.h>
#include <caml/mlvalues.h>
#include <caml/signals.h>

#include "libvirt_c_prologue.c"

#include "libvirt_c_oneoffs.c"

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTGETHOSTNAME
extern char *virConnectGetHostname (virConnectPtr conn) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_get_hostname (value connv)
{
  CAMLparam1 (connv);
#ifndef HAVE_VIRCONNECTGETHOSTNAME
  /* Symbol virConnectGetHostname not found at compile time. */
  not_supported ("virConnectGetHostname");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectGetHostname
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectGetHostname);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *r;

  NONBLOCKING (r = virConnectGetHostname (conn));
  CHECK_ERROR (!r, conn, "virConnectGetHostname");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTGETURI
extern char *virConnectGetURI (virConnectPtr conn) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_get_uri (value connv)
{
  CAMLparam1 (connv);
#ifndef HAVE_VIRCONNECTGETURI
  /* Symbol virConnectGetURI not found at compile time. */
  not_supported ("virConnectGetURI");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectGetURI
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectGetURI);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *r;

  NONBLOCKING (r = virConnectGetURI (conn));
  CHECK_ERROR (!r, conn, "virConnectGetURI");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_connect_get_type (value connv)
{
  CAMLparam1 (connv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  const char *r;

  NONBLOCKING (r = virConnectGetType (conn));
  CHECK_ERROR (!r, conn, "virConnectGetType");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_connect_num_of_domains (value connv)
{
  CAMLparam1 (connv);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfDomains (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfDomains");

  CAMLreturn (Val_int (r));
}

CAMLprim value
ocaml_libvirt_connect_list_domains (value connv, value iv)
{
  CAMLparam2 (connv, iv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  int ids[i], r;

  NONBLOCKING (r = virConnectListDomains (conn, ids, i));
  CHECK_ERROR (r == -1, conn, "virConnectListDomains");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i)
    Store_field (rv, i, Val_int (ids[i]));

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_connect_num_of_defined_domains (value connv)
{
  CAMLparam1 (connv);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfDefinedDomains (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfDefinedDomains");

  CAMLreturn (Val_int (r));
}

CAMLprim value
ocaml_libvirt_connect_list_defined_domains (value connv, value iv)
{
  CAMLparam2 (connv, iv);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListDefinedDomains (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListDefinedDomains");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_connect_num_of_networks (value connv)
{
  CAMLparam1 (connv);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfNetworks (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfNetworks");

  CAMLreturn (Val_int (r));
}

CAMLprim value
ocaml_libvirt_connect_list_networks (value connv, value iv)
{
  CAMLparam2 (connv, iv);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListNetworks (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListNetworks");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_connect_num_of_defined_networks (value connv)
{
  CAMLparam1 (connv);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfDefinedNetworks (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfDefinedNetworks");

  CAMLreturn (Val_int (r));
}

CAMLprim value
ocaml_libvirt_connect_list_defined_networks (value connv, value iv)
{
  CAMLparam2 (connv, iv);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListDefinedNetworks (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListDefinedNetworks");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTNUMOFSTORAGEPOOLS
extern int virConnectNumOfStoragePools (virConnectPtr conn) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_num_of_storage_pools (value connv)
{
  CAMLparam1 (connv);
#ifndef HAVE_VIRCONNECTNUMOFSTORAGEPOOLS
  /* Symbol virConnectNumOfStoragePools not found at compile time. */
  not_supported ("virConnectNumOfStoragePools");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectNumOfStoragePools
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectNumOfStoragePools);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfStoragePools (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfStoragePools");

  CAMLreturn (Val_int (r));
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTLISTSTORAGEPOOLS
extern int virConnectListStoragePools (virConnectPtr conn, char **const names, int maxnames) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_list_storage_pools (value connv, value iv)
{
  CAMLparam2 (connv, iv);
#ifndef HAVE_VIRCONNECTLISTSTORAGEPOOLS
  /* Symbol virConnectListStoragePools not found at compile time. */
  not_supported ("virConnectListStoragePools");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectListStoragePools
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectListStoragePools);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListStoragePools (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListStoragePools");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTNUMOFDEFINEDSTORAGEPOOLS
extern int virConnectNumOfDefinedStoragePools (virConnectPtr conn) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_num_of_defined_storage_pools (value connv)
{
  CAMLparam1 (connv);
#ifndef HAVE_VIRCONNECTNUMOFDEFINEDSTORAGEPOOLS
  /* Symbol virConnectNumOfDefinedStoragePools not found at compile time. */
  not_supported ("virConnectNumOfDefinedStoragePools");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectNumOfDefinedStoragePools
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectNumOfDefinedStoragePools);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfDefinedStoragePools (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfDefinedStoragePools");

  CAMLreturn (Val_int (r));
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTLISTDEFINEDSTORAGEPOOLS
extern int virConnectListDefinedStoragePools (virConnectPtr conn, char **const names, int maxnames) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_list_defined_storage_pools (value connv, value iv)
{
  CAMLparam2 (connv, iv);
#ifndef HAVE_VIRCONNECTLISTDEFINEDSTORAGEPOOLS
  /* Symbol virConnectListDefinedStoragePools not found at compile time. */
  not_supported ("virConnectListDefinedStoragePools");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectListDefinedStoragePools
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectListDefinedStoragePools);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListDefinedStoragePools (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListDefinedStoragePools");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_connect_get_capabilities (value connv)
{
  CAMLparam1 (connv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *r;

  NONBLOCKING (r = virConnectGetCapabilities (conn));
  CHECK_ERROR (!r, conn, "virConnectGetCapabilities");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_name (value domv)
{
  CAMLparam1 (domv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  const char *r;

  NONBLOCKING (r = virDomainGetName (dom));
  CHECK_ERROR (!r, conn, "virDomainGetName");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_os_type (value domv)
{
  CAMLparam1 (domv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char *r;

  NONBLOCKING (r = virDomainGetOSType (dom));
  CHECK_ERROR (!r, conn, "virDomainGetOSType");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_xml_desc (value domv)
{
  CAMLparam1 (domv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char *r;

  NONBLOCKING (r = virDomainGetXMLDesc (dom, 0));
  CHECK_ERROR (!r, conn, "virDomainGetXMLDesc");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_suspend (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainSuspend (dom));
  CHECK_ERROR (r == -1, conn, "virDomainSuspend");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_resume (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainResume (dom));
  CHECK_ERROR (r == -1, conn, "virDomainResume");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_shutdown (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainShutdown (dom));
  CHECK_ERROR (r == -1, conn, "virDomainShutdown");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_reboot (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainReboot (dom, 0));
  CHECK_ERROR (r == -1, conn, "virDomainReboot");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_undefine (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainUndefine (dom));
  CHECK_ERROR (r == -1, conn, "virDomainUndefine");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_create (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainCreate (dom));
  CHECK_ERROR (r == -1, conn, "virDomainCreate");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_network_get_name (value netv)
{
  CAMLparam1 (netv);

  CAMLlocal1 (rv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  const char *r;

  NONBLOCKING (r = virNetworkGetName (net));
  CHECK_ERROR (!r, conn, "virNetworkGetName");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_get_xml_desc (value netv)
{
  CAMLparam1 (netv);

  CAMLlocal1 (rv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  char *r;

  NONBLOCKING (r = virNetworkGetXMLDesc (net, 0));
  CHECK_ERROR (!r, conn, "virNetworkGetXMLDesc");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_get_bridge_name (value netv)
{
  CAMLparam1 (netv);

  CAMLlocal1 (rv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  char *r;

  NONBLOCKING (r = virNetworkGetBridgeName (net));
  CHECK_ERROR (!r, conn, "virNetworkGetBridgeName");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_undefine (value netv)
{
  CAMLparam1 (netv);

  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  int r;

  NONBLOCKING (r = virNetworkUndefine (net));
  CHECK_ERROR (r == -1, conn, "virNetworkUndefine");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_network_create (value netv)
{
  CAMLparam1 (netv);

  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  int r;

  NONBLOCKING (r = virNetworkCreate (net));
  CHECK_ERROR (r == -1, conn, "virNetworkCreate");

  CAMLreturn (Val_unit);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLGETNAME
extern const char *virStoragePoolGetName (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_get_name (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLGETNAME
  /* Symbol virStoragePoolGetName not found at compile time. */
  not_supported ("virStoragePoolGetName");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolGetName
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolGetName);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  const char *r;

  NONBLOCKING (r = virStoragePoolGetName (pool));
  CHECK_ERROR (!r, conn, "virStoragePoolGetName");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLGETXMLDESC
extern char *virStoragePoolGetXMLDesc (virStoragePoolPtr pool, int flags) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_get_xml_desc (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLGETXMLDESC
  /* Symbol virStoragePoolGetXMLDesc not found at compile time. */
  not_supported ("virStoragePoolGetXMLDesc");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolGetXMLDesc
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolGetXMLDesc);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  char *r;

  NONBLOCKING (r = virStoragePoolGetXMLDesc (pool, 0));
  CHECK_ERROR (!r, conn, "virStoragePoolGetXMLDesc");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLUNDEFINE
extern char *virStoragePoolUndefine (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_undefine (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLUNDEFINE
  /* Symbol virStoragePoolUndefine not found at compile time. */
  not_supported ("virStoragePoolUndefine");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolUndefine
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolUndefine);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  char *r;

  NONBLOCKING (r = virStoragePoolUndefine (pool));
  CHECK_ERROR (!r, conn, "virStoragePoolUndefine");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLCREATE
extern char *virStoragePoolCreate (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_create (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLCREATE
  /* Symbol virStoragePoolCreate not found at compile time. */
  not_supported ("virStoragePoolCreate");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolCreate
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolCreate);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  char *r;

  NONBLOCKING (r = virStoragePoolCreate (pool));
  CHECK_ERROR (!r, conn, "virStoragePoolCreate");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLSHUTDOWN
extern char *virStoragePoolShutdown (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_shutdown (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLSHUTDOWN
  /* Symbol virStoragePoolShutdown not found at compile time. */
  not_supported ("virStoragePoolShutdown");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolShutdown
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolShutdown);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  char *r;

  NONBLOCKING (r = virStoragePoolShutdown (pool));
  CHECK_ERROR (!r, conn, "virStoragePoolShutdown");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLREFRESH
extern char *virStoragePoolRefresh (virStoragePoolPtr pool, int flags) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_refresh (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLREFRESH
  /* Symbol virStoragePoolRefresh not found at compile time. */
  not_supported ("virStoragePoolRefresh");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolRefresh
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolRefresh);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  char *r;

  NONBLOCKING (r = virStoragePoolRefresh (pool, 0));
  CHECK_ERROR (!r, conn, "virStoragePoolRefresh");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLGETXMLDESC
extern char *virStorageVolGetXMLDesc (virStoragePoolPtr pool, int flags) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_get_xml_desc (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEVOLGETXMLDESC
  /* Symbol virStorageVolGetXMLDesc not found at compile time. */
  not_supported ("virStorageVolGetXMLDesc");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolGetXMLDesc
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolGetXMLDesc);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  char *r;

  NONBLOCKING (r = virStorageVolGetXMLDesc (pool, 0));
  CHECK_ERROR (!r, conn, "virStorageVolGetXMLDesc");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLGETPATH
extern char *virStorageVolGetPath (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_get_path (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEVOLGETPATH
  /* Symbol virStorageVolGetPath not found at compile time. */
  not_supported ("virStorageVolGetPath");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolGetPath
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolGetPath);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  char *r;

  NONBLOCKING (r = virStorageVolGetPath (pool));
  CHECK_ERROR (!r, conn, "virStorageVolGetPath");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLGETKEY
extern const char *virStorageVolGetKey (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_get_key (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEVOLGETKEY
  /* Symbol virStorageVolGetKey not found at compile time. */
  not_supported ("virStorageVolGetKey");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolGetKey
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolGetKey);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  const char *r;

  NONBLOCKING (r = virStorageVolGetKey (pool));
  CHECK_ERROR (!r, conn, "virStorageVolGetKey");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLGETNAME
extern const char *virStorageVolGetName (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_get_name (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEVOLGETNAME
  /* Symbol virStorageVolGetName not found at compile time. */
  not_supported ("virStorageVolGetName");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolGetName
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolGetName);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  const char *r;

  NONBLOCKING (r = virStorageVolGetName (pool));
  CHECK_ERROR (!r, conn, "virStorageVolGetName");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_domain_create_job ()
{
  failwith ("ocaml_libvirt_domain_create_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_domain_core_dump_job ()
{
  failwith ("ocaml_libvirt_domain_core_dump_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_domain_restore_job ()
{
  failwith ("ocaml_libvirt_domain_restore_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_domain_save_job ()
{
  failwith ("ocaml_libvirt_domain_save_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_connect_create_linux_job ()
{
  failwith ("ocaml_libvirt_connect_create_linux_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_network_create_job ()
{
  failwith ("ocaml_libvirt_network_create_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_network_create_xml_job ()
{
  failwith ("ocaml_libvirt_network_create_xml_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_set_autostart ()
{
  failwith ("ocaml_libvirt_storage_pool_set_autostart is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_get_autostart ()
{
  failwith ("ocaml_libvirt_storage_pool_get_autostart is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_get_info ()
{
  failwith ("ocaml_libvirt_storage_pool_get_info is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_get_uuid_string ()
{
  failwith ("ocaml_libvirt_storage_pool_get_uuid_string is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_get_uuid ()
{
  failwith ("ocaml_libvirt_storage_pool_get_uuid is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_free ()
{
  failwith ("ocaml_libvirt_storage_pool_free is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_destroy ()
{
  failwith ("ocaml_libvirt_storage_pool_destroy is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_define_xml ()
{
  failwith ("ocaml_libvirt_storage_pool_define_xml is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_create_xml ()
{
  failwith ("ocaml_libvirt_storage_pool_create_xml is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_lookup_by_uuid_string ()
{
  failwith ("ocaml_libvirt_storage_pool_lookup_by_uuid_string is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_lookup_by_uuid ()
{
  failwith ("ocaml_libvirt_storage_pool_lookup_by_uuid is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_lookup_by_name ()
{
  failwith ("ocaml_libvirt_storage_pool_lookup_by_name is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_free ()
{
  failwith ("ocaml_libvirt_storage_vol_free is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_destroy ()
{
  failwith ("ocaml_libvirt_storage_vol_destroy is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_create_xml ()
{
  failwith ("ocaml_libvirt_storage_vol_create_xml is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_get_info ()
{
  failwith ("ocaml_libvirt_storage_vol_get_info is unimplemented");
}

CAMLprim value
ocaml_libvirt_pool_of_volume ()
{
  failwith ("ocaml_libvirt_pool_of_volume is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_lookup_by_path ()
{
  failwith ("ocaml_libvirt_storage_vol_lookup_by_path is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_lookup_by_key ()
{
  failwith ("ocaml_libvirt_storage_vol_lookup_by_key is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_lookup_by_name ()
{
  failwith ("ocaml_libvirt_storage_vol_lookup_by_name is unimplemented");
}

CAMLprim value
ocaml_libvirt_job_cancel ()
{
  failwith ("ocaml_libvirt_job_cancel is unimplemented");
}

CAMLprim value
ocaml_libvirt_job_get_network ()
{
  failwith ("ocaml_libvirt_job_get_network is unimplemented");
}

CAMLprim value
ocaml_libvirt_job_get_domain ()
{
  failwith ("ocaml_libvirt_job_get_domain is unimplemented");
}

CAMLprim value
ocaml_libvirt_job_get_info ()
{
  failwith ("ocaml_libvirt_job_get_info is unimplemented");
}

#include "libvirt_c_epilogue.c"

/* EOF */
