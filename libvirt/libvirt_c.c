/* !!! WARNING WARNING WARNING WARNING WARNING WARNING WARNING !!!
 *
 * THIS FILE IS AUTOMATICALLY GENERATED BY 'generator.pl'.
 *
 * Any changes you make to this file may be overwritten.
 */

/* OCaml bindings for libvirt.
 * (C) Copyright 2007-2008 Richard W.M. Jones, Red Hat Inc.
 * http://libvirt.org/
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 */

#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <libvirt/libvirt.h>
#include <libvirt/virterror.h>

#include <caml/config.h>
#include <caml/alloc.h>
#include <caml/callback.h>
#include <caml/custom.h>
#include <caml/fail.h>
#include <caml/memory.h>
#include <caml/misc.h>
#include <caml/mlvalues.h>
#include <caml/signals.h>

#include "libvirt_c_prologue.c"

#include "libvirt_c_oneoffs.c"

CAMLprim value
ocaml_libvirt_connect_close (value connv)
{
  CAMLparam1 (connv);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectClose (conn));
  CHECK_ERROR (r == -1, conn, "virConnectClose");

  /* So that we don't double-free in the finalizer: */
  Connect_val (connv) = NULL;

  CAMLreturn (Val_unit);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTGETHOSTNAME
extern char *virConnectGetHostname (virConnectPtr conn) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_get_hostname (value connv)
{
  CAMLparam1 (connv);
#ifndef HAVE_VIRCONNECTGETHOSTNAME
  /* Symbol virConnectGetHostname not found at compile time. */
  not_supported ("virConnectGetHostname");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectGetHostname
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectGetHostname);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *r;

  NONBLOCKING (r = virConnectGetHostname (conn));
  CHECK_ERROR (!r, conn, "virConnectGetHostname");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTGETURI
extern char *virConnectGetURI (virConnectPtr conn) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_get_uri (value connv)
{
  CAMLparam1 (connv);
#ifndef HAVE_VIRCONNECTGETURI
  /* Symbol virConnectGetURI not found at compile time. */
  not_supported ("virConnectGetURI");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectGetURI
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectGetURI);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *r;

  NONBLOCKING (r = virConnectGetURI (conn));
  CHECK_ERROR (!r, conn, "virConnectGetURI");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_connect_get_type (value connv)
{
  CAMLparam1 (connv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  const char *r;

  NONBLOCKING (r = virConnectGetType (conn));
  CHECK_ERROR (!r, conn, "virConnectGetType");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_connect_num_of_domains (value connv)
{
  CAMLparam1 (connv);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfDomains (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfDomains");

  CAMLreturn (Val_int (r));
}

CAMLprim value
ocaml_libvirt_connect_list_domains (value connv, value iv)
{
  CAMLparam2 (connv, iv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  int ids[i], r;

  NONBLOCKING (r = virConnectListDomains (conn, ids, i));
  CHECK_ERROR (r == -1, conn, "virConnectListDomains");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i)
    Store_field (rv, i, Val_int (ids[i]));

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_connect_num_of_defined_domains (value connv)
{
  CAMLparam1 (connv);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfDefinedDomains (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfDefinedDomains");

  CAMLreturn (Val_int (r));
}

CAMLprim value
ocaml_libvirt_connect_list_defined_domains (value connv, value iv)
{
  CAMLparam2 (connv, iv);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListDefinedDomains (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListDefinedDomains");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_connect_num_of_networks (value connv)
{
  CAMLparam1 (connv);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfNetworks (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfNetworks");

  CAMLreturn (Val_int (r));
}

CAMLprim value
ocaml_libvirt_connect_list_networks (value connv, value iv)
{
  CAMLparam2 (connv, iv);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListNetworks (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListNetworks");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_connect_num_of_defined_networks (value connv)
{
  CAMLparam1 (connv);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfDefinedNetworks (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfDefinedNetworks");

  CAMLreturn (Val_int (r));
}

CAMLprim value
ocaml_libvirt_connect_list_defined_networks (value connv, value iv)
{
  CAMLparam2 (connv, iv);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListDefinedNetworks (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListDefinedNetworks");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTNUMOFSTORAGEPOOLS
extern int virConnectNumOfStoragePools (virConnectPtr conn) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_num_of_storage_pools (value connv)
{
  CAMLparam1 (connv);
#ifndef HAVE_VIRCONNECTNUMOFSTORAGEPOOLS
  /* Symbol virConnectNumOfStoragePools not found at compile time. */
  not_supported ("virConnectNumOfStoragePools");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectNumOfStoragePools
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectNumOfStoragePools);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfStoragePools (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfStoragePools");

  CAMLreturn (Val_int (r));
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTLISTSTORAGEPOOLS
extern int virConnectListStoragePools (virConnectPtr conn, char **const names, int maxnames) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_list_storage_pools (value connv, value iv)
{
  CAMLparam2 (connv, iv);
#ifndef HAVE_VIRCONNECTLISTSTORAGEPOOLS
  /* Symbol virConnectListStoragePools not found at compile time. */
  not_supported ("virConnectListStoragePools");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectListStoragePools
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectListStoragePools);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListStoragePools (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListStoragePools");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTNUMOFDEFINEDSTORAGEPOOLS
extern int virConnectNumOfDefinedStoragePools (virConnectPtr conn) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_num_of_defined_storage_pools (value connv)
{
  CAMLparam1 (connv);
#ifndef HAVE_VIRCONNECTNUMOFDEFINEDSTORAGEPOOLS
  /* Symbol virConnectNumOfDefinedStoragePools not found at compile time. */
  not_supported ("virConnectNumOfDefinedStoragePools");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectNumOfDefinedStoragePools
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectNumOfDefinedStoragePools);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfDefinedStoragePools (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfDefinedStoragePools");

  CAMLreturn (Val_int (r));
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTLISTDEFINEDSTORAGEPOOLS
extern int virConnectListDefinedStoragePools (virConnectPtr conn, char **const names, int maxnames) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_list_defined_storage_pools (value connv, value iv)
{
  CAMLparam2 (connv, iv);
#ifndef HAVE_VIRCONNECTLISTDEFINEDSTORAGEPOOLS
  /* Symbol virConnectListDefinedStoragePools not found at compile time. */
  not_supported ("virConnectListDefinedStoragePools");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectListDefinedStoragePools
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectListDefinedStoragePools);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListDefinedStoragePools (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListDefinedStoragePools");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_connect_get_capabilities (value connv)
{
  CAMLparam1 (connv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *r;

  NONBLOCKING (r = virConnectGetCapabilities (conn));
  CHECK_ERROR (!r, conn, "virConnectGetCapabilities");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_create_linux (value connv, value strv)
{
  CAMLparam2 (connv, strv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virDomainPtr r;

  NONBLOCKING (r = virDomainCreateLinux (conn, str, 0));
  CHECK_ERROR (!r, conn, "virDomainCreateLinux");

  rv = Val_domain (r, connv);

  CAMLreturn (rv);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRDOMAINCREATELINUXJOB
extern virJobPtr virDomainCreateLinuxJob (virConnectPtr conn, const char *str, unsigned  int flags) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_domain_create_linux_job (value connv, value strv)
{
  CAMLparam2 (connv, strv);
#ifndef HAVE_VIRDOMAINCREATELINUXJOB
  /* Symbol virDomainCreateLinuxJob not found at compile time. */
  not_supported ("virDomainCreateLinuxJob");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virDomainCreateLinuxJob
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virDomainCreateLinuxJob);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virJobPtr r;

  NONBLOCKING (r = virDomainCreateLinuxJob (conn, str, 0));
  CHECK_ERROR (!r, conn, "virDomainCreateLinuxJob");

  rv = Val_job (r, connv);

  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_domain_free (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainFree (dom));
  CHECK_ERROR (r == -1, conn, "virDomainFree");

  /* So that we don't double-free in the finalizer: */
  Domain_val (domv) = NULL;

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_destroy (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainDestroy (dom));
  CHECK_ERROR (r == -1, conn, "virDomainDestroy");

  /* So that we don't double-free in the finalizer: */
  Domain_val (domv) = NULL;

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_lookup_by_name (value connv, value strv)
{
  CAMLparam2 (connv, strv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virDomainPtr r;

  NONBLOCKING (r = virDomainLookupByName (conn, str));
  CHECK_ERROR (!r, conn, "virDomainLookupByName");

  rv = Val_domain (r, connv);

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_lookup_by_id (value connv, value iv)
{
  CAMLparam2 (connv, iv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  virDomainPtr r;

  NONBLOCKING (r = virDomainLookupByID (conn, i));
  CHECK_ERROR (!r, conn, "virDomainLookupByID");

  rv = Val_domain (r, connv);

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_lookup_by_uuid (value connv, value uuidv)
{
  CAMLparam2 (connv, uuidv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  unsigned char *uuid = (unsigned char *) String_val (uuidv);
  virDomainPtr r;

  NONBLOCKING (r = virDomainLookupByUUID (conn, uuid));
  CHECK_ERROR (!r, conn, "virDomainLookupByUUID");

  rv = Val_domain (r, connv);

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_lookup_by_uuid_string (value connv, value strv)
{
  CAMLparam2 (connv, strv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virDomainPtr r;

  NONBLOCKING (r = virDomainLookupByUUIDString (conn, str));
  CHECK_ERROR (!r, conn, "virDomainLookupByUUIDString");

  rv = Val_domain (r, connv);

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_name (value domv)
{
  CAMLparam1 (domv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  const char *r;

  NONBLOCKING (r = virDomainGetName (dom));
  CHECK_ERROR (!r, conn, "virDomainGetName");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_os_type (value domv)
{
  CAMLparam1 (domv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char *r;

  NONBLOCKING (r = virDomainGetOSType (dom));
  CHECK_ERROR (!r, conn, "virDomainGetOSType");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_xml_desc (value domv)
{
  CAMLparam1 (domv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char *r;

  NONBLOCKING (r = virDomainGetXMLDesc (dom, 0));
  CHECK_ERROR (!r, conn, "virDomainGetXMLDesc");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_uuid (value domv)
{
  CAMLparam1 (domv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  unsigned char uuid[VIR_UUID_BUFLEN];
  int r;

  NONBLOCKING (r = virDomainGetUUID (dom, uuid));
  CHECK_ERROR (r == -1, conn, "virDomainGetUUID");

  rv = caml_copy_string ((char *) uuid);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_uuid_string (value domv)
{
  CAMLparam1 (domv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char uuid[VIR_UUID_STRING_BUFLEN];
  int r;

  NONBLOCKING (r = virDomainGetUUIDString (dom, uuid));
  CHECK_ERROR (r == -1, conn, "virDomainGetUUIDString");

  rv = caml_copy_string (uuid);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_max_vcpus (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainGetMaxVcpus (dom));
  CHECK_ERROR (r == -1, conn, "virDomainGetMaxVcpus");

  CAMLreturn (Val_int (r));
}

CAMLprim value
ocaml_libvirt_domain_save (value domv, value strv)
{
  CAMLparam2 (domv, strv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char *str = String_val (strv);
  int r;

  NONBLOCKING (r = virDomainSave (dom, str));
  CHECK_ERROR (r == -1, conn, "virDomainSave");

  CAMLreturn (Val_unit);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRDOMAINSAVEJOB
extern virJobPtr virDomainSaveJob (virDomainPtr dom, const char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_domain_save_job (value domv, value strv)
{
  CAMLparam2 (domv, strv);
#ifndef HAVE_VIRDOMAINSAVEJOB
  /* Symbol virDomainSaveJob not found at compile time. */
  not_supported ("virDomainSaveJob");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virDomainSaveJob
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virDomainSaveJob);

  CAMLlocal2 (rv, connv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char *str = String_val (strv);
  virJobPtr r;

  NONBLOCKING (r = virDomainSaveJob (dom, str));
  CHECK_ERROR (!r, conn, "virDomainSaveJob");

  connv = Field (domv, 1);
  rv = Val_job (r, connv);

  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_domain_restore (value connv, value strv)
{
  CAMLparam2 (connv, strv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  int r;

  NONBLOCKING (r = virDomainRestore (conn, str));
  CHECK_ERROR (r == -1, conn, "virDomainRestore");

  CAMLreturn (Val_unit);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRDOMAINRESTOREJOB
extern virJobPtr virDomainRestoreJob (virConnectPtr conn, const char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_domain_restore_job (value connv, value strv)
{
  CAMLparam2 (connv, strv);
#ifndef HAVE_VIRDOMAINRESTOREJOB
  /* Symbol virDomainRestoreJob not found at compile time. */
  not_supported ("virDomainRestoreJob");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virDomainRestoreJob
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virDomainRestoreJob);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virJobPtr r;

  NONBLOCKING (r = virDomainRestoreJob (conn, str));
  CHECK_ERROR (!r, conn, "virDomainRestoreJob");

  rv = Val_job (r, connv);

  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_domain_core_dump (value domv, value strv)
{
  CAMLparam2 (domv, strv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char *str = String_val (strv);
  int r;

  NONBLOCKING (r = virDomainCoreDump (dom, str, 0));
  CHECK_ERROR (!r, conn, "virDomainCoreDump");

  CAMLreturn (Val_unit);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRDOMAINCOREDUMPJOB
extern virJobPtr virDomainCoreDumpJob (virDomainPtr dom, const char *str,  int flags) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_domain_core_dump_job (value domv, value strv)
{
  CAMLparam2 (domv, strv);
#ifndef HAVE_VIRDOMAINCOREDUMPJOB
  /* Symbol virDomainCoreDumpJob not found at compile time. */
  not_supported ("virDomainCoreDumpJob");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virDomainCoreDumpJob
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virDomainCoreDumpJob);

  CAMLlocal2 (rv, connv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char *str = String_val (strv);
  virJobPtr r;

  NONBLOCKING (r = virDomainCoreDumpJob (dom, str, 0));
  CHECK_ERROR (!r, conn, "virDomainCoreDumpJob");

  connv = Field (domv, 1);
  rv = Val_job (r, connv);

  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_domain_suspend (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainSuspend (dom));
  CHECK_ERROR (r == -1, conn, "virDomainSuspend");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_resume (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainResume (dom));
  CHECK_ERROR (r == -1, conn, "virDomainResume");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_shutdown (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainShutdown (dom));
  CHECK_ERROR (r == -1, conn, "virDomainShutdown");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_reboot (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainReboot (dom, 0));
  CHECK_ERROR (r == -1, conn, "virDomainReboot");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_define_xml (value connv, value strv)
{
  CAMLparam2 (connv, strv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virDomainPtr r;

  NONBLOCKING (r = virDomainDefineXML (conn, str));
  CHECK_ERROR (!r, conn, "virDomainDefineXML");

  rv = Val_domain (r, connv);

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_undefine (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainUndefine (dom));
  CHECK_ERROR (r == -1, conn, "virDomainUndefine");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_create (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainCreate (dom));
  CHECK_ERROR (r == -1, conn, "virDomainCreate");

  CAMLreturn (Val_unit);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRDOMAINCREATEJOB
extern virJobPtr virDomainCreateJob (virDomainPtr dom, unsigned  int flags) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_domain_create_job (value domv)
{
  CAMLparam1 (domv);
#ifndef HAVE_VIRDOMAINCREATEJOB
  /* Symbol virDomainCreateJob not found at compile time. */
  not_supported ("virDomainCreateJob");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virDomainCreateJob
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virDomainCreateJob);

  CAMLlocal2 (rv, connv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  virJobPtr r;

  NONBLOCKING (r = virDomainCreateJob (dom, 0));
  CHECK_ERROR (!r, conn, "virDomainCreateJob");

  connv = Field (domv, 1);
  rv = Val_job (r, connv);

  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_domain_attach_device (value domv, value strv)
{
  CAMLparam2 (domv, strv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char *str = String_val (strv);
  int r;

  NONBLOCKING (r = virDomainAttachDevice (dom, str));
  CHECK_ERROR (r == -1, conn, "virDomainAttachDevice");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_detach_device (value domv, value strv)
{
  CAMLparam2 (domv, strv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char *str = String_val (strv);
  int r;

  NONBLOCKING (r = virDomainDetachDevice (dom, str));
  CHECK_ERROR (r == -1, conn, "virDomainDetachDevice");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_get_autostart (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r, b;

  NONBLOCKING (r = virDomainGetAutostart (dom, &b));
  CHECK_ERROR (r == -1, conn, "virDomainGetAutostart");

  CAMLreturn (b ? Val_true : Val_false);
}

CAMLprim value
ocaml_libvirt_domain_set_autostart (value domv, value bv)
{
  CAMLparam2 (domv, bv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r, b;

  b = bv == Val_true ? 1 : 0;

  NONBLOCKING (r = virDomainSetAutostart (dom, b));
  CHECK_ERROR (r == -1, conn, "virDomainSetAutostart");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_network_free (value netv)
{
  CAMLparam1 (netv);

  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  int r;

  NONBLOCKING (r = virNetworkFree (net));
  CHECK_ERROR (r == -1, conn, "virNetworkFree");

  /* So that we don't double-free in the finalizer: */
  Network_val (netv) = NULL;

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_network_destroy (value netv)
{
  CAMLparam1 (netv);

  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  int r;

  NONBLOCKING (r = virNetworkDestroy (net));
  CHECK_ERROR (r == -1, conn, "virNetworkDestroy");

  /* So that we don't double-free in the finalizer: */
  Network_val (netv) = NULL;

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_network_lookup_by_name (value connv, value strv)
{
  CAMLparam2 (connv, strv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virNetworkPtr r;

  NONBLOCKING (r = virNetworkLookupByName (conn, str));
  CHECK_ERROR (!r, conn, "virNetworkLookupByName");

  rv = Val_network (r, connv);

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_lookup_by_uuid (value connv, value uuidv)
{
  CAMLparam2 (connv, uuidv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  unsigned char *uuid = (unsigned char *) String_val (uuidv);
  virNetworkPtr r;

  NONBLOCKING (r = virNetworkLookupByUUID (conn, uuid));
  CHECK_ERROR (!r, conn, "virNetworkLookupByUUID");

  rv = Val_network (r, connv);

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_lookup_by_uuid_string (value connv, value strv)
{
  CAMLparam2 (connv, strv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virNetworkPtr r;

  NONBLOCKING (r = virNetworkLookupByUUIDString (conn, str));
  CHECK_ERROR (!r, conn, "virNetworkLookupByUUIDString");

  rv = Val_network (r, connv);

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_get_name (value netv)
{
  CAMLparam1 (netv);

  CAMLlocal1 (rv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  const char *r;

  NONBLOCKING (r = virNetworkGetName (net));
  CHECK_ERROR (!r, conn, "virNetworkGetName");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_get_xml_desc (value netv)
{
  CAMLparam1 (netv);

  CAMLlocal1 (rv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  char *r;

  NONBLOCKING (r = virNetworkGetXMLDesc (net, 0));
  CHECK_ERROR (!r, conn, "virNetworkGetXMLDesc");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_get_bridge_name (value netv)
{
  CAMLparam1 (netv);

  CAMLlocal1 (rv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  char *r;

  NONBLOCKING (r = virNetworkGetBridgeName (net));
  CHECK_ERROR (!r, conn, "virNetworkGetBridgeName");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_get_uuid (value netv)
{
  CAMLparam1 (netv);

  CAMLlocal1 (rv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  unsigned char uuid[VIR_UUID_BUFLEN];
  int r;

  NONBLOCKING (r = virNetworkGetUUID (net, uuid));
  CHECK_ERROR (r == -1, conn, "virNetworkGetUUID");

  rv = caml_copy_string ((char *) uuid);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_get_uuid_string (value netv)
{
  CAMLparam1 (netv);

  CAMLlocal1 (rv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  char uuid[VIR_UUID_STRING_BUFLEN];
  int r;

  NONBLOCKING (r = virNetworkGetUUIDString (net, uuid));
  CHECK_ERROR (r == -1, conn, "virNetworkGetUUIDString");

  rv = caml_copy_string (uuid);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_undefine (value netv)
{
  CAMLparam1 (netv);

  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  int r;

  NONBLOCKING (r = virNetworkUndefine (net));
  CHECK_ERROR (r == -1, conn, "virNetworkUndefine");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_network_create_xml (value connv, value strv)
{
  CAMLparam2 (connv, strv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virNetworkPtr r;

  NONBLOCKING (r = virNetworkCreateXML (conn, str));
  CHECK_ERROR (!r, conn, "virNetworkCreateXML");

  rv = Val_network (r, connv);

  CAMLreturn (rv);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRNETWORKCREATEXMLJOB
extern virJobPtr virNetworkCreateXMLJob (virConnectPtr conn, const char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_network_create_xml_job (value connv, value strv)
{
  CAMLparam2 (connv, strv);
#ifndef HAVE_VIRNETWORKCREATEXMLJOB
  /* Symbol virNetworkCreateXMLJob not found at compile time. */
  not_supported ("virNetworkCreateXMLJob");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virNetworkCreateXMLJob
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virNetworkCreateXMLJob);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virJobPtr r;

  NONBLOCKING (r = virNetworkCreateXMLJob (conn, str));
  CHECK_ERROR (!r, conn, "virNetworkCreateXMLJob");

  rv = Val_job (r, connv);

  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_network_define_xml (value connv, value strv)
{
  CAMLparam2 (connv, strv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virNetworkPtr r;

  NONBLOCKING (r = virNetworkDefineXML (conn, str));
  CHECK_ERROR (!r, conn, "virNetworkDefineXML");

  rv = Val_network (r, connv);

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_create (value netv)
{
  CAMLparam1 (netv);

  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  int r;

  NONBLOCKING (r = virNetworkCreate (net));
  CHECK_ERROR (r == -1, conn, "virNetworkCreate");

  CAMLreturn (Val_unit);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRNETWORKCREATEJOB
extern virJobPtr virNetworkCreateJob (virNetworkPtr net) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_network_create_job (value netv)
{
  CAMLparam1 (netv);
#ifndef HAVE_VIRNETWORKCREATEJOB
  /* Symbol virNetworkCreateJob not found at compile time. */
  not_supported ("virNetworkCreateJob");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virNetworkCreateJob
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virNetworkCreateJob);

  CAMLlocal2 (rv, connv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  virJobPtr r;

  NONBLOCKING (r = virNetworkCreateJob (net));
  CHECK_ERROR (!r, conn, "virNetworkCreateJob");

  connv = Field (netv, 1);
  rv = Val_job (r, connv);

  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_network_get_autostart (value netv)
{
  CAMLparam1 (netv);

  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  int r, b;

  NONBLOCKING (r = virNetworkGetAutostart (net, &b));
  CHECK_ERROR (r == -1, conn, "virNetworkGetAutostart");

  CAMLreturn (b ? Val_true : Val_false);
}

CAMLprim value
ocaml_libvirt_network_set_autostart (value netv, value bv)
{
  CAMLparam2 (netv, bv);

  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  int r, b;

  b = bv == Val_true ? 1 : 0;

  NONBLOCKING (r = virNetworkSetAutostart (net, b));
  CHECK_ERROR (r == -1, conn, "virNetworkSetAutostart");

  CAMLreturn (Val_unit);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLFREE
extern int virStoragePoolFree (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_free (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLFREE
  /* Symbol virStoragePoolFree not found at compile time. */
  not_supported ("virStoragePoolFree");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolFree
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolFree);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r;

  NONBLOCKING (r = virStoragePoolFree (pool));
  CHECK_ERROR (r == -1, conn, "virStoragePoolFree");

  /* So that we don't double-free in the finalizer: */
  Pool_val (poolv) = NULL;

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLDESTROY
extern int virStoragePoolDestroy (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_destroy (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLDESTROY
  /* Symbol virStoragePoolDestroy not found at compile time. */
  not_supported ("virStoragePoolDestroy");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolDestroy
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolDestroy);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r;

  NONBLOCKING (r = virStoragePoolDestroy (pool));
  CHECK_ERROR (r == -1, conn, "virStoragePoolDestroy");

  /* So that we don't double-free in the finalizer: */
  Pool_val (poolv) = NULL;

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLLOOKUPBYNAME
extern virStoragePoolPtr virStoragePoolLookupByName (virConnectPtr conn, const char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_lookup_by_name (value connv, value strv)
{
  CAMLparam2 (connv, strv);
#ifndef HAVE_VIRSTORAGEPOOLLOOKUPBYNAME
  /* Symbol virStoragePoolLookupByName not found at compile time. */
  not_supported ("virStoragePoolLookupByName");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolLookupByName
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolLookupByName);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virStoragePoolPtr r;

  NONBLOCKING (r = virStoragePoolLookupByName (conn, str));
  CHECK_ERROR (!r, conn, "virStoragePoolLookupByName");

  rv = Val_pool (r, connv);

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLLOOKUPBYUUID
extern virStoragePoolPtr virStoragePoolLookupByUUID (virConnectPtr conn, const unsigned char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_lookup_by_uuid (value connv, value uuidv)
{
  CAMLparam2 (connv, uuidv);
#ifndef HAVE_VIRSTORAGEPOOLLOOKUPBYUUID
  /* Symbol virStoragePoolLookupByUUID not found at compile time. */
  not_supported ("virStoragePoolLookupByUUID");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolLookupByUUID
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolLookupByUUID);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  unsigned char *uuid = (unsigned char *) String_val (uuidv);
  virStoragePoolPtr r;

  NONBLOCKING (r = virStoragePoolLookupByUUID (conn, uuid));
  CHECK_ERROR (!r, conn, "virStoragePoolLookupByUUID");

  rv = Val_pool (r, connv);

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLLOOKUPBYUUIDSTRING
extern virStoragePoolPtr virStoragePoolLookupByUUIDString (virConnectPtr conn, const char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_lookup_by_uuid_string (value connv, value strv)
{
  CAMLparam2 (connv, strv);
#ifndef HAVE_VIRSTORAGEPOOLLOOKUPBYUUIDSTRING
  /* Symbol virStoragePoolLookupByUUIDString not found at compile time. */
  not_supported ("virStoragePoolLookupByUUIDString");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolLookupByUUIDString
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolLookupByUUIDString);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virStoragePoolPtr r;

  NONBLOCKING (r = virStoragePoolLookupByUUIDString (conn, str));
  CHECK_ERROR (!r, conn, "virStoragePoolLookupByUUIDString");

  rv = Val_pool (r, connv);

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLGETNAME
extern const char *virStoragePoolGetName (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_get_name (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLGETNAME
  /* Symbol virStoragePoolGetName not found at compile time. */
  not_supported ("virStoragePoolGetName");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolGetName
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolGetName);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  const char *r;

  NONBLOCKING (r = virStoragePoolGetName (pool));
  CHECK_ERROR (!r, conn, "virStoragePoolGetName");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLGETXMLDESC
extern char *virStoragePoolGetXMLDesc (virStoragePoolPtr pool,  int flags) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_get_xml_desc (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLGETXMLDESC
  /* Symbol virStoragePoolGetXMLDesc not found at compile time. */
  not_supported ("virStoragePoolGetXMLDesc");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolGetXMLDesc
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolGetXMLDesc);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  char *r;

  NONBLOCKING (r = virStoragePoolGetXMLDesc (pool, 0));
  CHECK_ERROR (!r, conn, "virStoragePoolGetXMLDesc");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLGETUUID
extern int virStoragePoolGetUUID (virStoragePoolPtr pool, unsigned char *) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_get_uuid (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLGETUUID
  /* Symbol virStoragePoolGetUUID not found at compile time. */
  not_supported ("virStoragePoolGetUUID");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolGetUUID
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolGetUUID);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  unsigned char uuid[VIR_UUID_BUFLEN];
  int r;

  NONBLOCKING (r = virStoragePoolGetUUID (pool, uuid));
  CHECK_ERROR (r == -1, conn, "virStoragePoolGetUUID");

  rv = caml_copy_string ((char *) uuid);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLGETUUIDSTRING
extern int virStoragePoolGetUUIDString (virStoragePoolPtr pool, char *) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_get_uuid_string (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLGETUUIDSTRING
  /* Symbol virStoragePoolGetUUIDString not found at compile time. */
  not_supported ("virStoragePoolGetUUIDString");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolGetUUIDString
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolGetUUIDString);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  char uuid[VIR_UUID_STRING_BUFLEN];
  int r;

  NONBLOCKING (r = virStoragePoolGetUUIDString (pool, uuid));
  CHECK_ERROR (r == -1, conn, "virStoragePoolGetUUIDString");

  rv = caml_copy_string (uuid);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLCREATEXML
extern virStoragePoolPtr virStoragePoolCreateXML (virConnectPtr conn, const char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_create_xml (value connv, value strv)
{
  CAMLparam2 (connv, strv);
#ifndef HAVE_VIRSTORAGEPOOLCREATEXML
  /* Symbol virStoragePoolCreateXML not found at compile time. */
  not_supported ("virStoragePoolCreateXML");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolCreateXML
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolCreateXML);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virStoragePoolPtr r;

  NONBLOCKING (r = virStoragePoolCreateXML (conn, str));
  CHECK_ERROR (!r, conn, "virStoragePoolCreateXML");

  rv = Val_pool (r, connv);

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLDEFINEXML
extern virStoragePoolPtr virStoragePoolDefineXML (virConnectPtr conn, const char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_define_xml (value connv, value strv)
{
  CAMLparam2 (connv, strv);
#ifndef HAVE_VIRSTORAGEPOOLDEFINEXML
  /* Symbol virStoragePoolDefineXML not found at compile time. */
  not_supported ("virStoragePoolDefineXML");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolDefineXML
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolDefineXML);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virStoragePoolPtr r;

  NONBLOCKING (r = virStoragePoolDefineXML (conn, str));
  CHECK_ERROR (!r, conn, "virStoragePoolDefineXML");

  rv = Val_pool (r, connv);

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLUNDEFINE
extern int virStoragePoolUndefine (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_undefine (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLUNDEFINE
  /* Symbol virStoragePoolUndefine not found at compile time. */
  not_supported ("virStoragePoolUndefine");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolUndefine
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolUndefine);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r;

  NONBLOCKING (r = virStoragePoolUndefine (pool));
  CHECK_ERROR (r == -1, conn, "virStoragePoolUndefine");

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLCREATE
extern int virStoragePoolCreate (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_create (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLCREATE
  /* Symbol virStoragePoolCreate not found at compile time. */
  not_supported ("virStoragePoolCreate");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolCreate
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolCreate);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r;

  NONBLOCKING (r = virStoragePoolCreate (pool));
  CHECK_ERROR (r == -1, conn, "virStoragePoolCreate");

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLSHUTDOWN
extern int virStoragePoolShutdown (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_shutdown (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLSHUTDOWN
  /* Symbol virStoragePoolShutdown not found at compile time. */
  not_supported ("virStoragePoolShutdown");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolShutdown
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolShutdown);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r;

  NONBLOCKING (r = virStoragePoolShutdown (pool));
  CHECK_ERROR (r == -1, conn, "virStoragePoolShutdown");

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLREFRESH
extern int virStoragePoolRefresh (virStoragePoolPtr pool, unsigned  int flags) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_refresh (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLREFRESH
  /* Symbol virStoragePoolRefresh not found at compile time. */
  not_supported ("virStoragePoolRefresh");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolRefresh
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolRefresh);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r;

  NONBLOCKING (r = virStoragePoolRefresh (pool, 0));
  CHECK_ERROR (r == -1, conn, "virStoragePoolRefresh");

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLGETAUTOSTART
extern int virStoragePoolGetAutostart (virStoragePoolPtr pool, int *r) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_get_autostart (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLGETAUTOSTART
  /* Symbol virStoragePoolGetAutostart not found at compile time. */
  not_supported ("virStoragePoolGetAutostart");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolGetAutostart
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolGetAutostart);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r, b;

  NONBLOCKING (r = virStoragePoolGetAutostart (pool, &b));
  CHECK_ERROR (r == -1, conn, "virStoragePoolGetAutostart");

  CAMLreturn (b ? Val_true : Val_false);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLSETAUTOSTART
extern int virStoragePoolSetAutostart (virStoragePoolPtr pool, int b) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_set_autostart (value poolv, value bv)
{
  CAMLparam2 (poolv, bv);
#ifndef HAVE_VIRSTORAGEPOOLSETAUTOSTART
  /* Symbol virStoragePoolSetAutostart not found at compile time. */
  not_supported ("virStoragePoolSetAutostart");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolSetAutostart
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolSetAutostart);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r, b;

  b = bv == Val_true ? 1 : 0;

  NONBLOCKING (r = virStoragePoolSetAutostart (pool, b));
  CHECK_ERROR (r == -1, conn, "virStoragePoolSetAutostart");

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLFREE
extern int virStorageVolFree (virStorageVolPtr vol) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_free (value volv)
{
  CAMLparam1 (volv);
#ifndef HAVE_VIRSTORAGEVOLFREE
  /* Symbol virStorageVolFree not found at compile time. */
  not_supported ("virStorageVolFree");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolFree
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolFree);

  virStorageVolPtr vol = Volume_val (volv);
  virConnectPtr conn = Connect_volv (volv);
  int r;

  NONBLOCKING (r = virStorageVolFree (vol));
  CHECK_ERROR (r == -1, conn, "virStorageVolFree");

  /* So that we don't double-free in the finalizer: */
  Volume_val (volv) = NULL;

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLDESTROY
extern int virStorageVolDestroy (virStorageVolPtr vol) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_destroy (value volv)
{
  CAMLparam1 (volv);
#ifndef HAVE_VIRSTORAGEVOLDESTROY
  /* Symbol virStorageVolDestroy not found at compile time. */
  not_supported ("virStorageVolDestroy");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolDestroy
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolDestroy);

  virStorageVolPtr vol = Volume_val (volv);
  virConnectPtr conn = Connect_volv (volv);
  int r;

  NONBLOCKING (r = virStorageVolDestroy (vol));
  CHECK_ERROR (r == -1, conn, "virStorageVolDestroy");

  /* So that we don't double-free in the finalizer: */
  Volume_val (volv) = NULL;

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLLOOKUPBYKEY
extern virStorageVolPtr virStorageVolLookupByKey (virConnectPtr conn, const char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_lookup_by_key (value connv, value strv)
{
  CAMLparam2 (connv, strv);
#ifndef HAVE_VIRSTORAGEVOLLOOKUPBYKEY
  /* Symbol virStorageVolLookupByKey not found at compile time. */
  not_supported ("virStorageVolLookupByKey");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolLookupByKey
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolLookupByKey);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virStorageVolPtr r;

  NONBLOCKING (r = virStorageVolLookupByKey (conn, str));
  CHECK_ERROR (!r, conn, "virStorageVolLookupByKey");

  rv = Val_volume (r, connv);

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLLOOKUPBYPATH
extern virStorageVolPtr virStorageVolLookupByPath (virConnectPtr conn, const char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_lookup_by_path (value connv, value strv)
{
  CAMLparam2 (connv, strv);
#ifndef HAVE_VIRSTORAGEVOLLOOKUPBYPATH
  /* Symbol virStorageVolLookupByPath not found at compile time. */
  not_supported ("virStorageVolLookupByPath");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolLookupByPath
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolLookupByPath);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virStorageVolPtr r;

  NONBLOCKING (r = virStorageVolLookupByPath (conn, str));
  CHECK_ERROR (!r, conn, "virStorageVolLookupByPath");

  rv = Val_volume (r, connv);

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLGETXMLDESC
extern char *virStorageVolGetXMLDesc (virStorageVolPtr vol,  int flags) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_get_xml_desc (value volv)
{
  CAMLparam1 (volv);
#ifndef HAVE_VIRSTORAGEVOLGETXMLDESC
  /* Symbol virStorageVolGetXMLDesc not found at compile time. */
  not_supported ("virStorageVolGetXMLDesc");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolGetXMLDesc
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolGetXMLDesc);

  CAMLlocal1 (rv);
  virStorageVolPtr vol = Volume_val (volv);
  virConnectPtr conn = Connect_volv (volv);
  char *r;

  NONBLOCKING (r = virStorageVolGetXMLDesc (vol, 0));
  CHECK_ERROR (!r, conn, "virStorageVolGetXMLDesc");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLGETPATH
extern char *virStorageVolGetPath (virStorageVolPtr vol) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_get_path (value volv)
{
  CAMLparam1 (volv);
#ifndef HAVE_VIRSTORAGEVOLGETPATH
  /* Symbol virStorageVolGetPath not found at compile time. */
  not_supported ("virStorageVolGetPath");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolGetPath
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolGetPath);

  CAMLlocal1 (rv);
  virStorageVolPtr vol = Volume_val (volv);
  virConnectPtr conn = Connect_volv (volv);
  char *r;

  NONBLOCKING (r = virStorageVolGetPath (vol));
  CHECK_ERROR (!r, conn, "virStorageVolGetPath");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLGETKEY
extern const char *virStorageVolGetKey (virStorageVolPtr vol) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_get_key (value volv)
{
  CAMLparam1 (volv);
#ifndef HAVE_VIRSTORAGEVOLGETKEY
  /* Symbol virStorageVolGetKey not found at compile time. */
  not_supported ("virStorageVolGetKey");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolGetKey
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolGetKey);

  CAMLlocal1 (rv);
  virStorageVolPtr vol = Volume_val (volv);
  virConnectPtr conn = Connect_volv (volv);
  const char *r;

  NONBLOCKING (r = virStorageVolGetKey (vol));
  CHECK_ERROR (!r, conn, "virStorageVolGetKey");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLGETNAME
extern const char *virStorageVolGetName (virStorageVolPtr vol) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_get_name (value volv)
{
  CAMLparam1 (volv);
#ifndef HAVE_VIRSTORAGEVOLGETNAME
  /* Symbol virStorageVolGetName not found at compile time. */
  not_supported ("virStorageVolGetName");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolGetName
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolGetName);

  CAMLlocal1 (rv);
  virStorageVolPtr vol = Volume_val (volv);
  virConnectPtr conn = Connect_volv (volv);
  const char *r;

  NONBLOCKING (r = virStorageVolGetName (vol));
  CHECK_ERROR (!r, conn, "virStorageVolGetName");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLLOOKUPBYVOLUME
extern virStoragePoolPtr virStoragePoolLookupByVolume (virStorageVolPtr vol) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_lookup_by_volume (value volv)
{
  CAMLparam1 (volv);
#ifndef HAVE_VIRSTORAGEPOOLLOOKUPBYVOLUME
  /* Symbol virStoragePoolLookupByVolume not found at compile time. */
  not_supported ("virStoragePoolLookupByVolume");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolLookupByVolume
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolLookupByVolume);

  CAMLlocal2 (rv, connv);
  virStorageVolPtr vol = Volume_val (volv);
  virConnectPtr conn = Connect_volv (volv);
  virStoragePoolPtr r;

  NONBLOCKING (r = virStoragePoolLookupByVolume (vol));
  CHECK_ERROR (!r, conn, "virStoragePoolLookupByVolume");

  connv = Field (volv, 1);
  rv = Val_pool (r, connv);

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRJOBFREE
extern int virJobFree (virJobPtr job) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_job_free (value jobv)
{
  CAMLparam1 (jobv);
#ifndef HAVE_VIRJOBFREE
  /* Symbol virJobFree not found at compile time. */
  not_supported ("virJobFree");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virJobFree
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virJobFree);

  virJobPtr job = Job_val (jobv);
  virConnectPtr conn = Connect_jobv (jobv);
  int r;

  NONBLOCKING (r = virJobFree (job));
  CHECK_ERROR (r == -1, conn, "virJobFree");

  /* So that we don't double-free in the finalizer: */
  Job_val (jobv) = NULL;

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRJOBCANCEL
extern int virJobCancel (virJobPtr job) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_job_cancel (value jobv)
{
  CAMLparam1 (jobv);
#ifndef HAVE_VIRJOBCANCEL
  /* Symbol virJobCancel not found at compile time. */
  not_supported ("virJobCancel");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virJobCancel
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virJobCancel);

  virJobPtr job = Job_val (jobv);
  virConnectPtr conn = Connect_jobv (jobv);
  int r;

  NONBLOCKING (r = virJobCancel (job));
  CHECK_ERROR (r == -1, conn, "virJobCancel");

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRJOBGETNETWORK
extern virNetworkPtr virJobGetNetwork (virJobPtr job) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_job_get_network (value jobv)
{
  CAMLparam1 (jobv);
#ifndef HAVE_VIRJOBGETNETWORK
  /* Symbol virJobGetNetwork not found at compile time. */
  not_supported ("virJobGetNetwork");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virJobGetNetwork
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virJobGetNetwork);

  CAMLlocal2 (rv, connv);
  virJobPtr job = Job_val (jobv);
  virConnectPtr conn = Connect_jobv (jobv);
  virNetworkPtr r;

  NONBLOCKING (r = virJobGetNetwork (job));
  CHECK_ERROR (!r, conn, "virJobGetNetwork");

  connv = Field (jobv, 1);
  rv = Val_network (r, connv);

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRJOBGETDOMAIN
extern virDomainPtr virJobGetDomain (virJobPtr job) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_job_get_domain (value jobv)
{
  CAMLparam1 (jobv);
#ifndef HAVE_VIRJOBGETDOMAIN
  /* Symbol virJobGetDomain not found at compile time. */
  not_supported ("virJobGetDomain");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virJobGetDomain
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virJobGetDomain);

  CAMLlocal2 (rv, connv);
  virJobPtr job = Job_val (jobv);
  virConnectPtr conn = Connect_jobv (jobv);
  virDomainPtr r;

  NONBLOCKING (r = virJobGetDomain (job));
  CHECK_ERROR (!r, conn, "virJobGetDomain");

  connv = Field (jobv, 1);
  rv = Val_domain (r, connv);

  CAMLreturn (rv);
#endif
}

/* The following functions are unimplemented and always fail.
 * See generator.pl '@unimplemented'
 */

CAMLprim value
ocaml_libvirt_storage_pool_get_info ()
{
  failwith ("ocaml_libvirt_storage_pool_get_info is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_lookup_by_name ()
{
  failwith ("ocaml_libvirt_storage_vol_lookup_by_name is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_create_xml ()
{
  failwith ("ocaml_libvirt_storage_vol_create_xml is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_get_info ()
{
  failwith ("ocaml_libvirt_storage_vol_get_info is unimplemented");
}

CAMLprim value
ocaml_libvirt_job_get_info ()
{
  failwith ("ocaml_libvirt_job_get_info is unimplemented");
}

#include "libvirt_c_epilogue.c"

/* EOF */
