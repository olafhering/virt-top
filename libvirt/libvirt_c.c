/* !!! WARNING WARNING WARNING WARNING WARNING WARNING WARNING !!!
 *
 * THIS FILE IS AUTOMATICALLY GENERATED BY 'generator.pl'.
 *
 * Any changes you make to this file may be overwritten.
 */

/* OCaml bindings for libvirt.
 * (C) Copyright 2007-2008 Richard W.M. Jones, Red Hat Inc.
 * http://libvirt.org/
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 */

#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <libvirt/libvirt.h>
#include <libvirt/virterror.h>

#include <caml/config.h>
#include <caml/alloc.h>
#include <caml/callback.h>
#include <caml/custom.h>
#include <caml/fail.h>
#include <caml/memory.h>
#include <caml/misc.h>
#include <caml/mlvalues.h>
#include <caml/signals.h>

#include "libvirt_c_prologue.c"

#include "libvirt_c_oneoffs.c"

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTGETHOSTNAME
extern char *virConnectGetHostname (virConnectPtr conn) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_get_hostname (value connv)
{
  CAMLparam1 (connv);
#ifndef HAVE_VIRCONNECTGETHOSTNAME
  /* Symbol virConnectGetHostname not found at compile time. */
  not_supported ("virConnectGetHostname");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectGetHostname
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectGetHostname);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *r;

  NONBLOCKING (r = virConnectGetHostname (conn));
  CHECK_ERROR (!r, conn, "virConnectGetHostname");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTGETURI
extern char *virConnectGetURI (virConnectPtr conn) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_get_uri (value connv)
{
  CAMLparam1 (connv);
#ifndef HAVE_VIRCONNECTGETURI
  /* Symbol virConnectGetURI not found at compile time. */
  not_supported ("virConnectGetURI");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectGetURI
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectGetURI);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *r;

  NONBLOCKING (r = virConnectGetURI (conn));
  CHECK_ERROR (!r, conn, "virConnectGetURI");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_connect_get_type (value connv)
{
  CAMLparam1 (connv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  const char *r;

  NONBLOCKING (r = virConnectGetType (conn));
  CHECK_ERROR (!r, conn, "virConnectGetType");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_connect_num_of_domains (value connv)
{
  CAMLparam1 (connv);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfDomains (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfDomains");

  CAMLreturn (Val_int (r));
}

CAMLprim value
ocaml_libvirt_connect_list_domains (value connv, value iv)
{
  CAMLparam2 (connv, iv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  int ids[i], r;

  NONBLOCKING (r = virConnectListDomains (conn, ids, i));
  CHECK_ERROR (r == -1, conn, "virConnectListDomains");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i)
    Store_field (rv, i, Val_int (ids[i]));

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_connect_num_of_defined_domains (value connv)
{
  CAMLparam1 (connv);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfDefinedDomains (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfDefinedDomains");

  CAMLreturn (Val_int (r));
}

CAMLprim value
ocaml_libvirt_connect_list_defined_domains (value connv, value iv)
{
  CAMLparam2 (connv, iv);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListDefinedDomains (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListDefinedDomains");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_connect_num_of_networks (value connv)
{
  CAMLparam1 (connv);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfNetworks (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfNetworks");

  CAMLreturn (Val_int (r));
}

CAMLprim value
ocaml_libvirt_connect_list_networks (value connv, value iv)
{
  CAMLparam2 (connv, iv);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListNetworks (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListNetworks");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_connect_num_of_defined_networks (value connv)
{
  CAMLparam1 (connv);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfDefinedNetworks (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfDefinedNetworks");

  CAMLreturn (Val_int (r));
}

CAMLprim value
ocaml_libvirt_connect_list_defined_networks (value connv, value iv)
{
  CAMLparam2 (connv, iv);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListDefinedNetworks (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListDefinedNetworks");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTNUMOFSTORAGEPOOLS
extern int virConnectNumOfStoragePools (virConnectPtr conn) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_num_of_storage_pools (value connv)
{
  CAMLparam1 (connv);
#ifndef HAVE_VIRCONNECTNUMOFSTORAGEPOOLS
  /* Symbol virConnectNumOfStoragePools not found at compile time. */
  not_supported ("virConnectNumOfStoragePools");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectNumOfStoragePools
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectNumOfStoragePools);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfStoragePools (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfStoragePools");

  CAMLreturn (Val_int (r));
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTLISTSTORAGEPOOLS
extern int virConnectListStoragePools (virConnectPtr conn, char **const names, int maxnames) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_list_storage_pools (value connv, value iv)
{
  CAMLparam2 (connv, iv);
#ifndef HAVE_VIRCONNECTLISTSTORAGEPOOLS
  /* Symbol virConnectListStoragePools not found at compile time. */
  not_supported ("virConnectListStoragePools");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectListStoragePools
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectListStoragePools);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListStoragePools (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListStoragePools");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTNUMOFDEFINEDSTORAGEPOOLS
extern int virConnectNumOfDefinedStoragePools (virConnectPtr conn) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_num_of_defined_storage_pools (value connv)
{
  CAMLparam1 (connv);
#ifndef HAVE_VIRCONNECTNUMOFDEFINEDSTORAGEPOOLS
  /* Symbol virConnectNumOfDefinedStoragePools not found at compile time. */
  not_supported ("virConnectNumOfDefinedStoragePools");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectNumOfDefinedStoragePools
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectNumOfDefinedStoragePools);

  virConnectPtr conn = Connect_val (connv);
  int r;

  NONBLOCKING (r = virConnectNumOfDefinedStoragePools (conn));
  CHECK_ERROR (r == -1, conn, "virConnectNumOfDefinedStoragePools");

  CAMLreturn (Val_int (r));
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRCONNECTLISTDEFINEDSTORAGEPOOLS
extern int virConnectListDefinedStoragePools (virConnectPtr conn, char **const names, int maxnames) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_connect_list_defined_storage_pools (value connv, value iv)
{
  CAMLparam2 (connv, iv);
#ifndef HAVE_VIRCONNECTLISTDEFINEDSTORAGEPOOLS
  /* Symbol virConnectListDefinedStoragePools not found at compile time. */
  not_supported ("virConnectListDefinedStoragePools");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virConnectListDefinedStoragePools
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virConnectListDefinedStoragePools);

  CAMLlocal2 (rv, strv);
  virConnectPtr conn = Connect_val (connv);
  int i = Int_val (iv);
  char *names[i];
  int r;

  NONBLOCKING (r = virConnectListDefinedStoragePools (conn, names, i));
  CHECK_ERROR (r == -1, conn, "virConnectListDefinedStoragePools");

  rv = caml_alloc (r, 0);
  for (i = 0; i < r; ++i) {
    strv = caml_copy_string (names[i]);
    Store_field (rv, i, strv);
    free (names[i]);
  }

  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_connect_get_capabilities (value connv)
{
  CAMLparam1 (connv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *r;

  NONBLOCKING (r = virConnectGetCapabilities (conn));
  CHECK_ERROR (!r, conn, "virConnectGetCapabilities");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_lookup_by_name (value connv, value strv)
{
  CAMLparam2 (connv, strv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virDomainPtr r;

  NONBLOCKING (r = virDomainLookupByName (conn, str));
  CHECK_ERROR (!r, conn, "virDomainLookupByName");

  rv = Val_domain (r, connv);

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_lookup_by_uuid_string (value connv, value strv)
{
  CAMLparam2 (connv, strv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virDomainPtr r;

  NONBLOCKING (r = virDomainLookupByUUIDString (conn, str));
  CHECK_ERROR (!r, conn, "virDomainLookupByUUIDString");

  rv = Val_domain (r, connv);

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_name (value domv)
{
  CAMLparam1 (domv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  const char *r;

  NONBLOCKING (r = virDomainGetName (dom));
  CHECK_ERROR (!r, conn, "virDomainGetName");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_os_type (value domv)
{
  CAMLparam1 (domv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char *r;

  NONBLOCKING (r = virDomainGetOSType (dom));
  CHECK_ERROR (!r, conn, "virDomainGetOSType");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_xml_desc (value domv)
{
  CAMLparam1 (domv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char *r;

  NONBLOCKING (r = virDomainGetXMLDesc (dom, 0));
  CHECK_ERROR (!r, conn, "virDomainGetXMLDesc");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_uuid (value domv)
{
  CAMLparam1 (domv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  unsigned char uuid[VIR_UUID_BUFLEN];
  int r;

  NONBLOCKING (r = virDomainGetUUID (dom, uuid));
  CHECK_ERROR (r == -1, conn, "virDomainGetUUID");

  rv = caml_copy_string ((char *) uuid);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_get_uuid_string (value domv)
{
  CAMLparam1 (domv);

  CAMLlocal1 (rv);
  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  char uuid[VIR_UUID_STRING_BUFLEN];
  int r;

  NONBLOCKING (r = virDomainGetUUIDString (dom, uuid));
  CHECK_ERROR (r == -1, conn, "virDomainGetUUIDString");

  rv = caml_copy_string (uuid);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_domain_suspend (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainSuspend (dom));
  CHECK_ERROR (r == -1, conn, "virDomainSuspend");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_resume (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainResume (dom));
  CHECK_ERROR (r == -1, conn, "virDomainResume");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_shutdown (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainShutdown (dom));
  CHECK_ERROR (r == -1, conn, "virDomainShutdown");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_reboot (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainReboot (dom, 0));
  CHECK_ERROR (r == -1, conn, "virDomainReboot");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_undefine (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainUndefine (dom));
  CHECK_ERROR (r == -1, conn, "virDomainUndefine");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_create (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r;

  NONBLOCKING (r = virDomainCreate (dom));
  CHECK_ERROR (r == -1, conn, "virDomainCreate");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_domain_get_autostart (value domv)
{
  CAMLparam1 (domv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r, b;

  NONBLOCKING (r = virDomainGetAutostart (dom, &b));
  CHECK_ERROR (r == -1, conn, "virDomainGetAutostart");

  CAMLreturn (b ? Val_true : Val_false);
}

CAMLprim value
ocaml_libvirt_domain_set_autostart (value domv, value bv)
{
  CAMLparam2 (domv, bv);

  virDomainPtr dom = Domain_val (domv);
  virConnectPtr conn = Connect_domv (domv);
  int r, b;

  b = bv == Val_true ? 1 : 0;

  NONBLOCKING (r = virDomainSetAutostart (dom, b));
  CHECK_ERROR (r == -1, conn, "virDomainSetAutostart");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_network_lookup_by_name (value connv, value strv)
{
  CAMLparam2 (connv, strv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virNetworkPtr r;

  NONBLOCKING (r = virNetworkLookupByName (conn, str));
  CHECK_ERROR (!r, conn, "virNetworkLookupByName");

  rv = Val_network (r, connv);

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_lookup_by_uuid_string (value connv, value strv)
{
  CAMLparam2 (connv, strv);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virNetworkPtr r;

  NONBLOCKING (r = virNetworkLookupByUUIDString (conn, str));
  CHECK_ERROR (!r, conn, "virNetworkLookupByUUIDString");

  rv = Val_network (r, connv);

  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_get_name (value netv)
{
  CAMLparam1 (netv);

  CAMLlocal1 (rv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  const char *r;

  NONBLOCKING (r = virNetworkGetName (net));
  CHECK_ERROR (!r, conn, "virNetworkGetName");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_get_xml_desc (value netv)
{
  CAMLparam1 (netv);

  CAMLlocal1 (rv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  char *r;

  NONBLOCKING (r = virNetworkGetXMLDesc (net, 0));
  CHECK_ERROR (!r, conn, "virNetworkGetXMLDesc");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_get_bridge_name (value netv)
{
  CAMLparam1 (netv);

  CAMLlocal1 (rv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  char *r;

  NONBLOCKING (r = virNetworkGetBridgeName (net));
  CHECK_ERROR (!r, conn, "virNetworkGetBridgeName");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_get_uuid (value netv)
{
  CAMLparam1 (netv);

  CAMLlocal1 (rv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  unsigned char uuid[VIR_UUID_BUFLEN];
  int r;

  NONBLOCKING (r = virNetworkGetUUID (net, uuid));
  CHECK_ERROR (r == -1, conn, "virNetworkGetUUID");

  rv = caml_copy_string ((char *) uuid);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_get_uuid_string (value netv)
{
  CAMLparam1 (netv);

  CAMLlocal1 (rv);
  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  char uuid[VIR_UUID_STRING_BUFLEN];
  int r;

  NONBLOCKING (r = virNetworkGetUUIDString (net, uuid));
  CHECK_ERROR (r == -1, conn, "virNetworkGetUUIDString");

  rv = caml_copy_string (uuid);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_libvirt_network_undefine (value netv)
{
  CAMLparam1 (netv);

  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  int r;

  NONBLOCKING (r = virNetworkUndefine (net));
  CHECK_ERROR (r == -1, conn, "virNetworkUndefine");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_network_create (value netv)
{
  CAMLparam1 (netv);

  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  int r;

  NONBLOCKING (r = virNetworkCreate (net));
  CHECK_ERROR (r == -1, conn, "virNetworkCreate");

  CAMLreturn (Val_unit);
}

CAMLprim value
ocaml_libvirt_network_get_autostart (value netv)
{
  CAMLparam1 (netv);

  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  int r, b;

  NONBLOCKING (r = virNetworkGetAutostart (net, &b));
  CHECK_ERROR (r == -1, conn, "virNetworkGetAutostart");

  CAMLreturn (b ? Val_true : Val_false);
}

CAMLprim value
ocaml_libvirt_network_set_autostart (value netv, value bv)
{
  CAMLparam2 (netv, bv);

  virNetworkPtr net = Network_val (netv);
  virConnectPtr conn = Connect_netv (netv);
  int r, b;

  b = bv == Val_true ? 1 : 0;

  NONBLOCKING (r = virNetworkSetAutostart (net, b));
  CHECK_ERROR (r == -1, conn, "virNetworkSetAutostart");

  CAMLreturn (Val_unit);
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLLOOKUPBYNAME
extern virStoragePoolPtr virStoragePoolLookupByName (virConnectPtr conn, const char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_lookup_by_name (value connv, value strv)
{
  CAMLparam2 (connv, strv);
#ifndef HAVE_VIRSTORAGEPOOLLOOKUPBYNAME
  /* Symbol virStoragePoolLookupByName not found at compile time. */
  not_supported ("virStoragePoolLookupByName");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolLookupByName
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolLookupByName);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virStoragePoolPtr r;

  NONBLOCKING (r = virStoragePoolLookupByName (conn, str));
  CHECK_ERROR (!r, conn, "virStoragePoolLookupByName");

  rv = Val_pool (r, connv);

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLLOOKUPBYUUIDSTRING
extern virStoragePoolPtr virStoragePoolLookupByUUIDString (virConnectPtr conn, const char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_lookup_by_uuid_string (value connv, value strv)
{
  CAMLparam2 (connv, strv);
#ifndef HAVE_VIRSTORAGEPOOLLOOKUPBYUUIDSTRING
  /* Symbol virStoragePoolLookupByUUIDString not found at compile time. */
  not_supported ("virStoragePoolLookupByUUIDString");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolLookupByUUIDString
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolLookupByUUIDString);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virStoragePoolPtr r;

  NONBLOCKING (r = virStoragePoolLookupByUUIDString (conn, str));
  CHECK_ERROR (!r, conn, "virStoragePoolLookupByUUIDString");

  rv = Val_pool (r, connv);

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLGETNAME
extern const char *virStoragePoolGetName (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_get_name (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLGETNAME
  /* Symbol virStoragePoolGetName not found at compile time. */
  not_supported ("virStoragePoolGetName");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolGetName
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolGetName);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  const char *r;

  NONBLOCKING (r = virStoragePoolGetName (pool));
  CHECK_ERROR (!r, conn, "virStoragePoolGetName");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLGETXMLDESC
extern char *virStoragePoolGetXMLDesc (virStoragePoolPtr pool,  int flags) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_get_xml_desc (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLGETXMLDESC
  /* Symbol virStoragePoolGetXMLDesc not found at compile time. */
  not_supported ("virStoragePoolGetXMLDesc");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolGetXMLDesc
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolGetXMLDesc);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  char *r;

  NONBLOCKING (r = virStoragePoolGetXMLDesc (pool, 0));
  CHECK_ERROR (!r, conn, "virStoragePoolGetXMLDesc");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLGETUUID
extern int virStoragePoolGetUUID (virStoragePoolPtr pool, unsigned char *) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_get_uuid (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLGETUUID
  /* Symbol virStoragePoolGetUUID not found at compile time. */
  not_supported ("virStoragePoolGetUUID");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolGetUUID
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolGetUUID);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  unsigned char uuid[VIR_UUID_BUFLEN];
  int r;

  NONBLOCKING (r = virStoragePoolGetUUID (pool, uuid));
  CHECK_ERROR (r == -1, conn, "virStoragePoolGetUUID");

  rv = caml_copy_string ((char *) uuid);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLGETUUIDSTRING
extern int virStoragePoolGetUUIDString (virStoragePoolPtr pool, char *) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_get_uuid_string (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLGETUUIDSTRING
  /* Symbol virStoragePoolGetUUIDString not found at compile time. */
  not_supported ("virStoragePoolGetUUIDString");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolGetUUIDString
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolGetUUIDString);

  CAMLlocal1 (rv);
  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  char uuid[VIR_UUID_STRING_BUFLEN];
  int r;

  NONBLOCKING (r = virStoragePoolGetUUIDString (pool, uuid));
  CHECK_ERROR (r == -1, conn, "virStoragePoolGetUUIDString");

  rv = caml_copy_string (uuid);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLUNDEFINE
extern int virStoragePoolUndefine (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_undefine (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLUNDEFINE
  /* Symbol virStoragePoolUndefine not found at compile time. */
  not_supported ("virStoragePoolUndefine");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolUndefine
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolUndefine);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r;

  NONBLOCKING (r = virStoragePoolUndefine (pool));
  CHECK_ERROR (r == -1, conn, "virStoragePoolUndefine");

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLCREATE
extern int virStoragePoolCreate (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_create (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLCREATE
  /* Symbol virStoragePoolCreate not found at compile time. */
  not_supported ("virStoragePoolCreate");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolCreate
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolCreate);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r;

  NONBLOCKING (r = virStoragePoolCreate (pool));
  CHECK_ERROR (r == -1, conn, "virStoragePoolCreate");

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLSHUTDOWN
extern int virStoragePoolShutdown (virStoragePoolPtr pool) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_shutdown (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLSHUTDOWN
  /* Symbol virStoragePoolShutdown not found at compile time. */
  not_supported ("virStoragePoolShutdown");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolShutdown
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolShutdown);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r;

  NONBLOCKING (r = virStoragePoolShutdown (pool));
  CHECK_ERROR (r == -1, conn, "virStoragePoolShutdown");

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLREFRESH
extern int virStoragePoolRefresh (virStoragePoolPtr pool, unsigned  int flags) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_refresh (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLREFRESH
  /* Symbol virStoragePoolRefresh not found at compile time. */
  not_supported ("virStoragePoolRefresh");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolRefresh
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolRefresh);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r;

  NONBLOCKING (r = virStoragePoolRefresh (pool, 0));
  CHECK_ERROR (r == -1, conn, "virStoragePoolRefresh");

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLGETAUTOSTART
extern int virStoragePoolGetAutostart (virStoragePoolPtr pool, int *r) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_get_autostart (value poolv)
{
  CAMLparam1 (poolv);
#ifndef HAVE_VIRSTORAGEPOOLGETAUTOSTART
  /* Symbol virStoragePoolGetAutostart not found at compile time. */
  not_supported ("virStoragePoolGetAutostart");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolGetAutostart
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolGetAutostart);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r, b;

  NONBLOCKING (r = virStoragePoolGetAutostart (pool, &b));
  CHECK_ERROR (r == -1, conn, "virStoragePoolGetAutostart");

  CAMLreturn (b ? Val_true : Val_false);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEPOOLSETAUTOSTART
extern int virStoragePoolSetAutostart (virStoragePoolPtr pool, int b) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_pool_set_autostart (value poolv, value bv)
{
  CAMLparam2 (poolv, bv);
#ifndef HAVE_VIRSTORAGEPOOLSETAUTOSTART
  /* Symbol virStoragePoolSetAutostart not found at compile time. */
  not_supported ("virStoragePoolSetAutostart");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStoragePoolSetAutostart
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStoragePoolSetAutostart);

  virStoragePoolPtr pool = Pool_val (poolv);
  virConnectPtr conn = Connect_polv (poolv);
  int r, b;

  b = bv == Val_true ? 1 : 0;

  NONBLOCKING (r = virStoragePoolSetAutostart (pool, b));
  CHECK_ERROR (r == -1, conn, "virStoragePoolSetAutostart");

  CAMLreturn (Val_unit);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLLOOKUPBYKEY
extern virStorageVolPtr virStorageVolLookupByKey (virConnectPtr conn, const char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_lookup_by_key (value connv, value strv)
{
  CAMLparam2 (connv, strv);
#ifndef HAVE_VIRSTORAGEVOLLOOKUPBYKEY
  /* Symbol virStorageVolLookupByKey not found at compile time. */
  not_supported ("virStorageVolLookupByKey");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolLookupByKey
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolLookupByKey);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virStorageVolPtr r;

  NONBLOCKING (r = virStorageVolLookupByKey (conn, str));
  CHECK_ERROR (!r, conn, "virStorageVolLookupByKey");

  rv = Val_volume (r, connv);

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLLOOKUPBYPATH
extern virStorageVolPtr virStorageVolLookupByPath (virConnectPtr conn, const char *str) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_lookup_by_path (value connv, value strv)
{
  CAMLparam2 (connv, strv);
#ifndef HAVE_VIRSTORAGEVOLLOOKUPBYPATH
  /* Symbol virStorageVolLookupByPath not found at compile time. */
  not_supported ("virStorageVolLookupByPath");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolLookupByPath
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolLookupByPath);

  CAMLlocal1 (rv);
  virConnectPtr conn = Connect_val (connv);
  char *str = String_val (strv);
  virStorageVolPtr r;

  NONBLOCKING (r = virStorageVolLookupByPath (conn, str));
  CHECK_ERROR (!r, conn, "virStorageVolLookupByPath");

  rv = Val_volume (r, connv);

  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLGETXMLDESC
extern char *virStorageVolGetXMLDesc (virStorageVolPtr vol,  int flags) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_get_xml_desc (value volv)
{
  CAMLparam1 (volv);
#ifndef HAVE_VIRSTORAGEVOLGETXMLDESC
  /* Symbol virStorageVolGetXMLDesc not found at compile time. */
  not_supported ("virStorageVolGetXMLDesc");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolGetXMLDesc
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolGetXMLDesc);

  CAMLlocal1 (rv);
  virStorageVolPtr vol = Volume_val (volv);
  virConnectPtr conn = Connect_volv (volv);
  char *r;

  NONBLOCKING (r = virStorageVolGetXMLDesc (vol, 0));
  CHECK_ERROR (!r, conn, "virStorageVolGetXMLDesc");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLGETPATH
extern char *virStorageVolGetPath (virStorageVolPtr vol) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_get_path (value volv)
{
  CAMLparam1 (volv);
#ifndef HAVE_VIRSTORAGEVOLGETPATH
  /* Symbol virStorageVolGetPath not found at compile time. */
  not_supported ("virStorageVolGetPath");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolGetPath
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolGetPath);

  CAMLlocal1 (rv);
  virStorageVolPtr vol = Volume_val (volv);
  virConnectPtr conn = Connect_volv (volv);
  char *r;

  NONBLOCKING (r = virStorageVolGetPath (vol));
  CHECK_ERROR (!r, conn, "virStorageVolGetPath");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLGETKEY
extern const char *virStorageVolGetKey (virStorageVolPtr vol) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_get_key (value volv)
{
  CAMLparam1 (volv);
#ifndef HAVE_VIRSTORAGEVOLGETKEY
  /* Symbol virStorageVolGetKey not found at compile time. */
  not_supported ("virStorageVolGetKey");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolGetKey
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolGetKey);

  CAMLlocal1 (rv);
  virStorageVolPtr vol = Volume_val (volv);
  virConnectPtr conn = Connect_volv (volv);
  const char *r;

  NONBLOCKING (r = virStorageVolGetKey (vol));
  CHECK_ERROR (!r, conn, "virStorageVolGetKey");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
#endif
}

#ifdef HAVE_WEAK_SYMBOLS
#ifdef HAVE_VIRSTORAGEVOLGETNAME
extern const char *virStorageVolGetName (virStorageVolPtr vol) __attribute__((weak));
#endif
#endif

CAMLprim value
ocaml_libvirt_storage_vol_get_name (value volv)
{
  CAMLparam1 (volv);
#ifndef HAVE_VIRSTORAGEVOLGETNAME
  /* Symbol virStorageVolGetName not found at compile time. */
  not_supported ("virStorageVolGetName");
  /* Suppresses a compiler warning. */
  (void) caml__frame;
#else
  /* Check that the symbol virStorageVolGetName
   * is in runtime version of libvirt.
   */
  WEAK_SYMBOL_CHECK (virStorageVolGetName);

  CAMLlocal1 (rv);
  virStorageVolPtr vol = Volume_val (volv);
  virConnectPtr conn = Connect_volv (volv);
  const char *r;

  NONBLOCKING (r = virStorageVolGetName (vol));
  CHECK_ERROR (!r, conn, "virStorageVolGetName");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
#endif
}

CAMLprim value
ocaml_libvirt_domain_create_job ()
{
  failwith ("ocaml_libvirt_domain_create_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_domain_core_dump_job ()
{
  failwith ("ocaml_libvirt_domain_core_dump_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_domain_restore_job ()
{
  failwith ("ocaml_libvirt_domain_restore_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_domain_save_job ()
{
  failwith ("ocaml_libvirt_domain_save_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_connect_create_linux_job ()
{
  failwith ("ocaml_libvirt_connect_create_linux_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_network_create_job ()
{
  failwith ("ocaml_libvirt_network_create_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_network_create_xml_job ()
{
  failwith ("ocaml_libvirt_network_create_xml_job is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_get_info ()
{
  failwith ("ocaml_libvirt_storage_pool_get_info is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_free ()
{
  failwith ("ocaml_libvirt_storage_pool_free is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_destroy ()
{
  failwith ("ocaml_libvirt_storage_pool_destroy is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_define_xml ()
{
  failwith ("ocaml_libvirt_storage_pool_define_xml is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_create_xml ()
{
  failwith ("ocaml_libvirt_storage_pool_create_xml is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_pool_lookup_by_uuid ()
{
  failwith ("ocaml_libvirt_storage_pool_lookup_by_uuid is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_lookup_by_name ()
{
  failwith ("ocaml_libvirt_storage_vol_lookup_by_name is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_free ()
{
  failwith ("ocaml_libvirt_storage_vol_free is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_destroy ()
{
  failwith ("ocaml_libvirt_storage_vol_destroy is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_create_xml ()
{
  failwith ("ocaml_libvirt_storage_vol_create_xml is unimplemented");
}

CAMLprim value
ocaml_libvirt_storage_vol_get_info ()
{
  failwith ("ocaml_libvirt_storage_vol_get_info is unimplemented");
}

CAMLprim value
ocaml_libvirt_pool_of_volume ()
{
  failwith ("ocaml_libvirt_pool_of_volume is unimplemented");
}

CAMLprim value
ocaml_libvirt_job_cancel ()
{
  failwith ("ocaml_libvirt_job_cancel is unimplemented");
}

CAMLprim value
ocaml_libvirt_job_get_network ()
{
  failwith ("ocaml_libvirt_job_get_network is unimplemented");
}

CAMLprim value
ocaml_libvirt_job_get_domain ()
{
  failwith ("ocaml_libvirt_job_get_domain is unimplemented");
}

CAMLprim value
ocaml_libvirt_job_get_info ()
{
  failwith ("ocaml_libvirt_job_get_info is unimplemented");
}

#include "libvirt_c_epilogue.c"

/* EOF */
